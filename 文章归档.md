# 文章归档

## Aobing Java
[AobingJava-Github](https://github.com/AobingJava/JavaFamily)

### 数据库

- Title add ...

- [我说 SELECT COUNT(*) 会造成全表扫描，面试官让我回去等通知](https://mp.weixin.qq.com/s/SNRvdmyS57oWS_CyYKVvSA)

  - sql选用索引成本计算

    - `select count(*)` 使用最小成本索引，不走全表

    - IO成本，CPU成本

  - 使用 `set optimizer_trace="enabled=on";`, `SELECT * FROM information_schema.OPTIMIZER_TRACE;` 查看Mysql的优化器生成过程

- [我说 SELECT COUNT(*) 会造成全表扫描，面试官让我回去等通知](https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ)

  - binlog，记录变更表结构、数据的sql语句；主从复制，监听变化（监听对象）
  
  - undo log，事务回溯（记录相反操作，inser->delete, update->update\[reverse\]）&MVCC
  
  - redo log，页修改记录，修改数据后数据库出错依此恢复

- [你说说一条更新SQL的执行过程？](https://mp.weixin.qq.com/s/-5N6eg1yMBUvDMbJOXp0eg)

  - 执行过程：连接器->解析器->优化器->执行引擎->存储引擎

    - 执行引擎：记录bin log

    - 存储引擎：记录redo log，undo log

  - redo log刷入硬盘：进缓冲（redo_log_buffer）-> redo_log_file

    - 参数：`innodb_flush_log_at_trx_commit`，默认值`1`

      - `0`: 提交不写入硬盘

      - `1`: 提交就写入硬盘

      - `2`: 提交写入文件缓存（内核/操作系统）

  - bin log: 缓存控制参数-`sync_binlog`，默认值0，由文件系统（缓存）控制

- [一条SQL语句执行得很慢的原因有哪些](https://mp.weixin.qq.com/s/YKmFEtHcZPBn1S9so0kxYw)

  - redo log: 内存中更新完记录并将记录写入redo log，空闲时通过redo log将更行记录写入硬盘

  - `show processlist`: 查看执行情况-（其一）判断锁情况


### Spring

- [CGLib源码分析（四）](https://www.cnblogs.com/cruze/p/3865180.html)

  - 获得代理类和FastClass `System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, {(根项目路径)./自定义})`

- [SpringAOP面试题](https://mp.weixin.qq.com/s/qlAvW10TRNVak1oJyHO39Q)

  - 核心AspectJ（**依赖项仅使用spring-context 不包含 AspectJ 下列注解**）：
  
    - `@Aspcet` or `<aop:aspect>`; Join Point;  
    
    - `@PointCut()`; 使用通配符 `*` `?`，表达式有:
    
      - `execution({modifiers-pattern方法访问类型?} [ret-type-pattern返回类型] {declaring-type-pattern?限定符}[name-pattern方法名]([param-pattern参数]) {throws-pattern?异常类型})`; example: `@Pointcut("execution(*[任意返回类型] com.mustse.ctrl..[包括本包及子包]*[任意类].*[任意方法](..[任意参数]))")`
      
      - `target()`
      
      - `within([value])` 实现 value 接口的方法
      
      - `@annotation([注解全限定名])` 有对应注解的方法
      
      - `@args()`
      
      - `bean()`
    
    - Advice: `@Around` or `@Before` or `@After` or `@Exception` or `@Return` or `@AfterReturning` or `@AfterThrowing` + (function_name); 
    
    - Weaving

- 过程：

  1. spring aop 针对 `@Pointcut` 匹配项生成代理类（CGlib）

  2. 生成6个回调（CGlib MethodInterceptor），其中一个回调  `DynamicAdvisedInterceptor` 用于处理 AspectJ 中 Advice

  3. `DynamicAdvisedInterceptor` 生成 advice 链，链中包含 `InterceptorAndDynamicMethodMatcher`（封装了 `MethodInceptor` 和 `MethodMatcher`\[动态方法匹配\]） 和 `MethodInterceptor`，并通过 `CglibAopProxy.CglibMethodInvocation` 处理

  4. `CglibAopProxy.CglibMethodInvocation` 实际是 `ReflectiveMethodInvocation` 的子类，在 `proceed()` 中使用 advice 链（对应成员 `interceptorsAndDynamicMethodMatchers`）中 `InterceptorAndDynamicMethodMatcher` （instanceof 类型判断）成员对当前方法和目标类进行动态判断，并执行相应 `MethodInterceptor#invoke()`

  5. 若链中项目非 `InterceptorAndDynamicMethodMatcher` 而是 `MethodInterceptor`, 则直接执行 `invoke()`

  6. `invoke()` 中参数均为 `this`（`CglibAopProxy.CglibMethodInvocation`/`ReflectiveMethodInvocation`）

  5. advice 链中，Spring 放置了 `ExposeInvocationInterceptor` 作为起始，使用了责任链设计模式。将对应 `ProxyMethodInvocation(ReflectiveMethodInvocation/CglibMethodInvocation)` 放入前者 `ThreadLocal` 中，在链执行结束前保证当前线程的执行情况唯一

  6. **责任链模式**：1-拥有链的实例选择链中项目，执行项目；2-项目执行相应逻辑后再次调用链（回到链），再次执行1-；在实现方式上类似递归的栈——等到栈顶依次弹出后才能执行后续语句

- advice 链中的项目（advice 排序后顺序 `AspectJAwareAdvisorAutoProxyCreator#sortAdvisors()`）：

  1. `org.springframework.aop.aspectj.AspectJAroundAdvice`

  2. `org.springframework.aop.aspectj.AspectJMethodBeforeAdvice`

  3. `org.springframework.aop.aspectj.AspectJAfterAdvice`

  4. `org.springframework.aop.aspectj.AspectJAfterReturningAdvice`

  5. `org.springframework.aop.aspectj.AspectJAfterThrowingAdvice`

- [Spring事务传播行为](https://mp.weixin.qq.com/s/IglQITCkmx7Lpz60QOW7HA)

  - 开启Spring事务传播：`@Transaction(Progation=xxx)`

  - `Progation` 选项：

    1. `REQUIRE`: 当前无事务，则创建新事务。若有，则加入（常用）

    2. `REQUIRE_NEW`: 新建事务，若有事务则挂起该事务

    3. `NOT_SUPPORT`: 若有事务则挂起，以无事务执行

    4. `MANDATORY`: 使用当前事务，若无事务则抛出异常

    5. `SUPPORT`: 若有事务则加入（支持），若当前无事务，则无事务方式执行

    6. `NEVER`: 无事务执行，存在事务则抛出错误

    7. `NESTED`: 存在事务，则嵌套在事务内执行（为子事务），无事务，则创建新事务

  - 事务未加入同一外围事务，则独立运行

  - `require` 与 `neseted` 区别：
  
    1. `neseted` 在有事务时生成子事务，有独立保存点，子事务（被外围函数调用的函数）出现异常且被捕获时，独自回滚，主事务正常。

    2. **重点**：
    
      - 若外围函数“感知”有异常（来自子事务/被调用函数），`nested` 和 `require` 事务（包括子事务）回滚；
      
      - 若被调函数抛出异常被外围函数捕获`try...catch`，则 `require` 中主事务回滚（同一事务），`nesetd` 中仅子事务（掷错）回滚。

  - 使用场景：理解为事务与事务之间存在双向关系，关系不对等时可考虑 `require`, `nesetd`, `not_support` 交替使用：注册服务使用 `require`，积分服务使用 `nested`（积分依赖注册，注册不依赖积分），日志服务使用 `not_support`（注册和积分均不依赖于此）

- [什么是 Spring 循环依赖？](https://mp.weixin.qq.com/s/5mwkgJB7GyLdKDgzijyvXw)

  - 定义：多个 Bean(Component) 之间相互依赖（比如 `@Autowire`），在创建相应 Bean 之前 BeanFactory 会将所需依赖注入，产生顺序问题。

  - 特殊：原型 (prototype) 不支持循环依赖 (`BeanCurrentlyInCreationException`)

  - 解决（“三级缓存”-三个 Map）：（于 `DefaultSingletonBeanRegistry`）

    1. `singletonObjects`

    2. `singletonFactories`
    
    3. `earlySingletonObjects`

  - 三级缓存使用过程：
    
    1. 从 `getSingleton()` 尝试获得对应 bean 单例，但无（null）
    
    2. 从 `doCreateBean()` 中将对应 Bean 的 `ObjectFactory` 放入 \[`singletonFactories`\] 中（并没有限定，只要符合单例可循环依赖要求则均可入 `singletonFactories`——参考 "two sum"）

    3. 使用 `populateBean()` 发现循环依赖项，重复 1，2，3

    4. 在某次进入 `getSingleton()` 时，发现对应 bean 的 `ObjectFactory` 存在，则使用以生成实例并放入 \[`earlySingletonObjects`\]，删除 \[`singletonFactories`\]对应 `ObjectFactory`，此时返回进入 `populateBean()`

    5. bean获得依赖(`earlySingletonObjects`) 后依赖填入完成，并前者加入 \[`singletonObjects`\]，删除对应后者 \[ `earlySingletonObjects`\] 缓存，返回上层 `populateBean()`

    6. 上层 bean 获得依赖，重复 5 ，直到栈空
    
    0.  暂存
    > 1. 通过 `BeanDefinition#isSingleton()` && `AbstractAutowireCapableBeanFactory.allowCircularReferences` && `AACBF#isSingletonCurrentlyInCreation()` 判断bean是否为可循环引用单例
    
    >  2.  `AACBF#doCreateBean()` 中，向 `DefaultListableBeanRegistry#addSingletonFactory()` 中添加 `ObjectFactory` （后者本质直接返回 bean）\[ 使用缓存 `singletonFactories` \]

    >  3. `AABCBF#populateBean()` 中，发现依赖项，使用 `AABCBF#doCreateBean()` 创建，重复 `1`, `2`

    >  4. `AACBF#doCreateBean()`中，通过 `DefaultListableBeanRegistry#getSingleton()` 

  - （暂存）`two sum` 算法：给定一个数组，给定一个数字。返回数组中可以相加得到指定数字的两个索引。
    ```java
    class Solution {
    public int[] twoSum(int[] nums, int target) {
      // 目标值唯一，则nums中任意数只有唯一的配对值
      // 且若在nums中存在对应值则之后可遍历到，反过来得相同结果
      // 故将每个遍历但未中得值放入map中
      Map<Integer, Integer> map = new HashMap<>();
      for (int i = 0; i < nums.length; i++) {
          int complement = target - nums[i];
          if (map.containsKey(complement)) {
              return new int[] { map.get(complement), i };
          }
          map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
      }
    }
    //作者：LeetCode
    //链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/
    //来源：力扣（LeetCode）
    ```

  - 与 `two sum` 关系：先将实例化的 Bean 放入缓存中（Map），然后从缓存中查找是否存在依赖项，不存在则创建（递归/循环），存在则获得放置后返回

  - 调用逻辑于 `AbstractAutowireCapableBeanFactory`，使用于 `存在于`

  

